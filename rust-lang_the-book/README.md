- [まえがき - The Rust Programming Language](https://doc.rust-jp.rs/book/second-edition/)
- 所感：この教材を読む前に、すでに２つの記事・教材を流し読みしてるから、読めているけれども、０ − ＞１でこの記事は辛い気がする、、、。１つのトピックでまるっと詰め込んで教えすぎてて、わけわかんなくなりそう。ある程度、知ってる人なら大丈夫だと思うけど、うーん。

## 1

- `cargo build`よりも`cargo check` でビルド可能か？は確認したほうが低コスト。

- クレートの英語的なニュアンス；https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AC%E3%83%BC%E3%83%88_(%E7%AE%B1)

## 2

- 関連関数。オブジェクトのインスタンスではなくて、型に対して実装されている関数のこと。（＝ Static メソッド）
- &: 参照：引数が参照であることを表し、これのおかげで、データを複数回メモリにコピーせずとも、 コードの複数箇所で同じデータにアクセスできるようになるわけです

- シャドーイング：パイプラインが無い代わりに再束縛ができるので、同じ変数名で何度も let して再束縛すりゃいいのか。うーん、パイプラインのほうが美しいかな、、、。再定義して再代入してるみたいなんで、気持ち悪い。
  ```rust
  fn main() {
    let x = "OK";
    let x = x.to_string() + "_NG";
    let x = x.to_string() + "_OK";
    println!("{}", x);
    // => OK_NG_OK
  }
  ```

## 3

- mut vs shadowing
  - mut：型の変更ができない
  - shadowing：型の変更もできる
- signed/unsigned
  - i32 / f64 がとりあえずのベターな選択
- 配列とベクタ
  - 配列：固定長のケース（const 系のみ）
  - ベクタ：それ以外の可変のすべてのケース。
- 式と文
  - 関数末尾にセミコロンがないと return される。
  - 式は終端にセミコロンが、ない。
  - 文は終端にセミコロンが、ある。
  - 文は値を返さない。式は値を返す

## 4

### 所有権

動機：メモリ管理をしたい。
なんで？ヒープとスタックがある。
スタックは固定長、ヒープは可変長
プログラムでのリテラル、つまりハードコードされている文字列などはすべてスタックとして処理できる。
Rust 的には、リテラル（＝プログラムに書かれている実際の string/num など）は、ビルドされた結果にバイナリにハードコードされる。そのため、スタックメモリで、固定長だけど速度が早い。
しかし、ユーザー入力などの Input な値などの変数はどれくらいの大きさの数が入るかわからない。つまり、どれくらいメモリ領域を確保すればよいかが事前にはわからない。そのため、ヒープメモリ、つまり可変長になる。

可変長なヒープメモリはポインタを使って複数のメモリ空間を横断してデータを保持する。そして、メモリ空間は任意のタイミングで掃除しないといけない。今までの言語では、GC にて定期的にクリーンにしていた。Rust では所有権によってスコープ単位で不要になった変数、つまり使用しているメモリ領域を drop する。

Copy トレイトに適合している i32/bool/char などはスタックメモリなので、別の変数に束縛してもムーブしない。

### スタックとヒープで挙動が違う

```rust
fn main() {
    let x = 2;
    let y = x;
    println!("{}, {}", x, y); // => 2, 2
}
```

```rust
fn main() {
    let x = String::from("ok");
    let y = x;
    println!("{}, {}", x, y); // => Error
}
```

すでに x のポインタ・長さ・許容量のメタデータをｙに「ムーブ」しているので。

### 参照渡し

```rust
let x = 2;
func1(x)
// or
func2(&x)

fn func1(x: i32) {
  // ...
}
fn func2(x: &i32) {
  // ...
}
```

- 借用＝関数の引数に参照を取ること。
- 借用ではイミュータブル。変更したいなら、`&mut i32` の宣言子がになる
- 借用では、所有権を持っているわけではない。

### スライス

- スライス＝可変配列
- 文字列スライス（&str）＝ String への参照（部分参照もできる
- 文字列リテラルは&str で、不変な場所の参照。

## 5

### 構造体

- 構造体*初期化*省略\_記法
  - `User { name: name } = User { name }`
- 構造体*更新*記法
  - `User { ..user1 }`
- タプル構造体
  - `Point(0, 1, 2)` / `Color(255, 255, 0)`

### impl

- impl で構造体に関数を生やす。（ダックプログラミング）
- 規則：impl の中の fn の第一引数は`&self`にする。これで構造体自体にアクセスできる。`self` / `&mut self`でも OK。
- 関数とメソッドは違う。関数は外界にある fn、メソッドは impl 内にある fn を指す。
- 関連関数：impl 内に実装されてるけど、self アクセスがない。

## 6

- enum 列挙子

  - enum の列挙しているのは値。ただ、特有の値で string とかではない。あくまで、同一 enum 同士で比較などができるだけぽい。

    ```rust
      #[derive(Debug)]
      enum Type {
        User,
        Admin
      }

      let t = Type::User;
      println!("{:?}", t); // => User
    ```

  - 列挙子として型も付与できる。型が違ってても OK。
    ```rust
      enum Type {
        yen(i32),
        daller(f32),
      }
    ```
  - enum で列挙子つきで、多種に定義することは、イコール struct で細かく定義してるのと同義。
  - enum にも impl でメソッドを定義できる

- match
  - rust には null がない。けれども、その概念は必要。それが Option モナド。
  - モナドの処理をさばくときに、match を使うことが多いよね。
  - match はパターンが包括されている必要がある。Option の場合は、Some/None の両方をアームで書かないとコンパイルエラー。
  - これで、match 不足のミスをコンパイルレベルで解決できる。
- if_let_else 記法
  - 特定の match のパターンに対する糖衣構文。
  - １つの値にしか match しないケース ⇒if_let 記法
  - １つの値への match か、それ以外のケース ⇒if-let-else 記法

## 7

- module
  - `mod` でモジュール化する。
  - `mod xxx;` だと、xxx.rs を見に行く。xxx.rs では mod で wrap しないで OK。
  - `use`で使用する。
    - `super`で１つ上の階層にあがる。
- ファイル
  - `mod.rs` / `main.rs` / `lib.rs`

## 8

- Vector
  - feature
    - ヒープリスト
    - 同一の型を扱う。
    - 別の型を扱いたいなら、enum で定義したものを型として扱う
  - 作成
    - `let v: Vec<i32> = Vec::from([1, 2, 3]);`
    - = `let v = vec![1, 2, 3];` ( マクロが用意されてる。型も推論される。)
  - 更新
    - `let mut v = vec![1, 2, 3];`
    - `v.push(2);`
  - 取得
    - 添字で取るか、.get で取るか
    - `let v = v[2]; // => v = 2 or panic when compiling`
    - `let v = v.get(2); // => v = Option(2) or None`
  - 複数の型
    - enum で型を定義して、その型のベクタを作る。
    - `enum T { I(i32), F(f64), S(String)};`
    - `let v = vec![T::I(2), T::F(2.2), T::S(String::from("OK"))];`
- 文字列
  - Rust 界隈での文字列は、String と&str のことを指す（すでにややこしい・・・）
  - Rust のコアには str/&str しかない。
  - Rust の標準ライブラリに String がある
  - Rust の標準ライブラリにその他の OsString、CString などがある。
  - 規則：string ＝所有権有り、str ＝借用されたバージョン。
  - idx でアクセスは良くない。人間の可読文字数ではなくて、UTF の処理区分で区切られてるから。２つの配列要素をまたぐデータもあり、そこでデータを切ってアクセスすると panic になる。
- ハッシュマップ

  - Rust における HashMap は連想配列のこと。

  ```rust
  use std::collections::HashMap;
  //
  let mut map = HashMap::new();
  map.insert(key, value);
  map.get(key); // => Option(&value)

  // keyのvalueが存在するかのチェッカーがentryで、そのモナドな型のEntry
  map.entry(key) // Entry(...)
    .or_insert(value) // 値がなければ、これでvalueが挿入
  ```

## 9

- error
  - エラー
    - panic / Result モナドのどちらか
    - match ガードと呼ばれる、match 条件の enhance な構文もあり。
    - match の &は参照にマッチして、ref は値にマッチしつつ値を返す
  - match のネストが深くなることがあるので、便利な関数がある
    - `unwrap`：Ok ならそのまま、Err なら panic する。`fun.unwrap();`
    - `expect`：`unwrap`でエラーメッセージを引数に持たせる。あれ、unwrap いらなくない？禁止したほうが良さげ。
  - エラーの委譲(delegation)
    - 自分で作った関数の返り値を値ではなくて Result にして、実際の値は Ok か Err を返すようにすればよい。
    - これを便利に書くための演算子が`?`。(ex) `let mut f = File::open("hello.txt")?`
    - これで、error なら quick return。Ok(v)なら v になる。

## 10

- trait
  - interface/abstract のようなもの。
  - インターフェース：`pub trait <trait> { fn <xxx> -> () {...} }`
  - 実装：`impl <trait> for <struct> {...}`
  - fn のオーバーライドが可能
- trait 境界(trait bound)
  - ジェネリクスにトレイトを指定することで、「引数がそのトレイトを実装していないといけない」という制約ができる
  - （普通のジェネリクス：`fn foo<T>(item: T) -> T { return item; }`）
  - 普通の記法
    - trait 境界：`fn foo<T: ThisIsTrait>(item: T) -> T { return item; }`
    - 記法：`<型変数: トレイト名>`、`<T: Display + Clone >`
  - where 記法
    - `+`でトレイトをつなげたり、トレイと境界が多いと可読性が悪いので、そういう場合は where 記法で記載する
    - 記法：`fn foo<T, U>(t: T, u: U) -> i32 where T: Display + Clone, U: Clone + Debug {...}`
  - impl 時の型にてトレイトをしているすることで、トレイトごとに参照するメソッドを振り分けることができる
    ```rust
    struct Animal {}
    impl<T: Dog + Cat> Animal {
      fn walk(){...}
     }
    impl<T: Bird> Animal {
      fn fly(){...}
    }
    ```
- ライフタイム
  - いつまで、ある変数の参照・借用の権限を持っているか？をライフタイムとして管理する。
  - Rust コンパイラには、借用チェッカーがあり、これでライフタイムの有無がわかる
  - ジェネリックなライフタイム引数
    - いつ：引数が参照で返り値も参照な関数があり、それらに関係性がある場合はライフタイム引数が必要になる
    - なぜ：それらの関係性がわからないと、ライフタイムチェッカーが所有権・借用のライフタイムを理解できない。
    - 記法：`'`。`&'a i32` / `&'a mut i32` / `'static str`（変数は a から始まる。static でスタックメモリな内容
    - ex: `fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {...`
    - 引数のライフタイム＝入力ライフタイム。戻り値のライフタイム＝出力ライフタイム。

## 11

- test
  - `#[ここに注釈]`
  - `#[test]`
  - `#[cfg](test)`: configuration
- 単体
  - 同一ファイル内に tests mod を作り、そこでテストをする
  - 非公開モジュールもテストできる。
- 結合
  - `/src/tests`のディレクトリを切る。
  - 個別のクレートになる。そのため、テストしたい mod は`extern crate クレート名`で宣言も必要。
  - 普通に命名してヘルパファイルを作成するとテスト対象になってしまう。`src/tests/common.rs`
  - モジュールの規約に従ってヘルパファイルを作成すると非テスト対象になる。`src/tests/common/mod.rs`

## 12

- 出力
  - 標準出力：`println!`
  - エラー出力：`eprintln!`

## 13

- クロージャ

  - ユースケース：コードを１箇所で定義したいけれども、結果が必要なところでのみ実行したい。関数定義とほぼ同じ。
  - `Fn(u32) -> u32` = function 型

- クロージャ：変数のキャプチャ
  ```rust
  let x = 2;
  let c = |num| num == x; // <== ここでのxがキャプチャされた変数
  ```
  - クロージャではなくて、関数の中で関数を定義することも可能。ただし、引数以外に値を外から取れない（＝変数をキャプチャする）
  - FnOnce：キャプチャした変数を、所有権を奪って自身にムーブ。
  - FnMut：キャプチャした変数を、可変で値を借用。
  - Fn：キャプチャした変数を、不変で借用。
  - move キーワード：キャプチャした変数をムーブさせる
  ```rust
   let x=1;
   let closure = move |num| num == x; // ここで、x の所有権がmove
   x // << Error。すでに所有権がないので。
  ```

## 14

- イテレータ
  - イテレータを実行するためには、データを変換させないといけない。
    - Iter の型
      - `for item in i.iter() { ... }`
    - index + 値のタプル
      - `for (idx, item) in i.iter().enumerate() { ... }`
  - Iterator トレイト
    - 消費アダプタ（consuming adaptors）：Iterator トレイトに実装されてる、消費系のメソッドを呼び出す。
      - next：mut で値を次々に移動させる。消費される。
      - collect: map などのイテレータを解決させる
    - イテレータアダプタ（iterator adaptors）：Iterator トレイトに実装されてる、別のイテレータに変換するメソッド。
  - 消費とイテレータ
    - イテレータを最終的に「消費」させないといけない。
    - sum：⇒ イテレートを回して、最終的に値に変換＝消費されてる
    - map：イテレートを回してるだけ。まだ消費されてない。
- dot
  - テスト： `///`
  - 生成：`cargo doc`
  - クレート全体へのコメント：`//! comment`

## 15

- スマートポインタ
  - 参照は借用、スマートポインタは所有。
  - スマートポインタは構造体で、Deref/Drop トレイトを実装していること。
- `Box<T>`
  - `Box<T>`＝ T の参照を持つ値。
  - ヒープにデータを格納し、スタックにそのポインタを持つ。
  - 再帰的な型はコンパイル時にサイズがわからない。これを、Box を使って実現する。
  - 間接参照：値を直接持たずに、値のポインタを格納する。
- 参照外し：`*`
  - 参照 x が指している値を取得する。`*x`
  - 実際は Deref トレイトの deref()を実行してるだけ。
  - `*x` => `*(x.deref()) // * は無効な文字になる`
- Box での参照外し：
  - `let y = Box::new(x); *y; // => OK`
- 参照外し型強制
  - `deref`にて、`&MyBox<String>` => `&String` に変換。
- デストラクタ
  - コンストラクタの逆で、インスタンスを片付ける関数のこと。
- `RC`
  - Reference Counting：参照カウント
  - 動機：複数の所有権を実現したい。
  - 「その値が生存しているかどうかを決定する値」への参照の数。
  - ０なら、どの参照を無効にすることなく、値を drop できる。
  - メタファー：テレビと家族。
  - シングルスレッドで使用するため「だけ」のもの。
- `RefCall`
  - Box がコンパイル時に、RefCall は実行時に発生。
  - 借用規則にコードが従っていても推論されないときは、Rust は保守的なので拒否をする。
  - そのときに、RefCall で明示化すれば、プログラマーの裁量でコードをコンパイル・実行できる。
  - シングルスレッドで「のみ」使われる。
  - （ここ難しすぎるので、流し読み、、、）
- 循環参照
  - （RefCall の続きなので、前提が難しいので、ここも流し読み、、、

## 16：並行・並列

- 前提
  - コードはプロセスで走り、プログラム内の独立した部分を同時実行させる機能をスレッド。
  - 1:1 モデル：（＝ネイティブスレッド）言語が OS の API を呼び出してスレッドを生成する。１つの OS スレッドに対して、１つの言語スレッド
    - Rust: バイナリサイズを小さくしたいので、ゼロランタイムを目指す。ゼロランタイムだと、バイナリサイズが小さい。その分、ランタイムに M:N を実現するコードを載せられない。
    - Java:
  - M:N モデル（＝グリーンスレッドモデル）：グリーンスレッド＝プログラミング言語が提供するスレッドのこと。異なる数の OS スレッドで実行され
    て、M 個のグリーンスレッド vsN 個の OS スレッドで、M と N はイコールでない。
    - Erlang: ErlangVM 上に複数のプロセスというグリーンスレッド。
    - Go: １つの OS スレッドにて、複数の go-routine というグリーンスレッド
- thread
  - spawn
    - thread::spawn の戻り値は JoinHandle 型
    - `let handle = thread::spawn(...);`
  - join
    - handle.join()で、スレッド処理が終了するまで待つ。async の await みたいに。
  - move
    - thread の中のクロージャにて、外界の値をキャプチャして使う場合は、所有権を move しないといけない。メインスレッドにて先にそのキャプチャした値の所有権が drop してるかもしれないので。
    - `let handle = thread::spawn(move || { ... });`
  - channel
    - チャンネル：川
    - 転送機(tx)：川にデータを流す。`tx.send()`
    - 受信機(rx)：川からデータを受け取る。`tr.recv()`
    - 転送・受信機の「どちらか」がドロップ＝チャネルが閉じる
    - mpsc: multiple-producer / single-consumer
  - mutex
    - ロックと開放が必要な手法。
    - 開放忘れの恐れがあるが Rust なら自動で drop する
  - `Arc<T>`: Atomic RC
    - RC はスレッドセーフに実行できない。Arc ならスレッドセーフに実行できる。
    - RC よりも Arc のほうがパフォーマンスコストがかかる。
- Send
  - 所有権をスレッドを超えて渡せる。

## 17

- トレイトオブジェクト
  - Box<T>などで、参照によってトレイトを示す値を持つ、オブジェクト。
- ステートマシン
  - 同一オブジェクトが持つプロパティ State を遷移させる。OOP 的で Rust 的でない。
    - ステートに依存して、プロパティの値を変えるが、ここで事故がおきる可能性がある。
  - 異なるオブジェクトへ変形させる。これが Rust 的。
    - ステートがなく、プロパティとの整合性が合わない事故が起きない。なぜなら、「コンパイルできないから」

## 18

- パターンマッチ
  - `if` / `if let` / `else if` / `else if let` を混ぜられる
  - `while let`
- 論駁可能
  - ＝全網羅でマッチしない可能性のあるタイプのマッチ式
- パターン
  - `|` => or
  - `..=` = range。num or string
  - 構造体の分配：`let Point {x: a, y: b} = p;`
  - `..`: rest：`let Point {x, .. } = p;`
  - `&`: 値の参照とマッチする
  - `ref` / `ref mut`: 値とマッチさせて、参照を作成する
  - `if`
    - `Some(x) if > 5 => { ... }`
    - `|`と`if`では、if はすべての値にかかる
    - `1 | 2 | 3 if false` = 必ず false になる
  - `@`: `Point{x: new_x @ 1..2, y} => {..}`

## 19

##

次：https://doc.rust-jp.rs/book/second-edition/ch18-00-patterns.html
