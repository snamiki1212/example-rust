- [まえがき - The Rust Programming Language](https://doc.rust-jp.rs/book/second-edition/)
- 所感：この教材を読む前に、すでに２つの記事・教材を流し読みしてるから、読めているけれども、０−＞１でこの記事は辛い気がする、、、。１つのトピックでまるっと詰め込んで教えすぎてて、わけわかんなくなりそう。ある程度、知ってる人なら大丈夫だと思うけど、うーん。

## 1

- `cargo build`よりも`cargo check` でビルド可能か？は確認したほうが低コスト。

- クレートの英語的なニュアンス；https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AC%E3%83%BC%E3%83%88_(%E7%AE%B1)

## 2

- 関連関数。オブジェクトのインスタンスではなくて、型に対して実装されている関数のこと。（＝Staticメソッド）
- &: 参照：引数が参照であることを表し、これのおかげで、データを複数回メモリにコピーせずとも、 コードの複数箇所で同じデータにアクセスできるようになるわけです

- シャドーイング：パイプラインが無い代わりに再束縛ができるので、同じ変数名で何度もletして再束縛すりゃいいのか。うーん、パイプラインのほうが美しいかな、、、。再定義して再代入してるみたいなんで、気持ち悪い。
  ```rust
  fn main() {
    let x = "OK";
    let x = x.to_string() + "_NG";
    let x = x.to_string() + "_OK";
    println!("{}", x);
    // => OK_NG_OK
  }
  ```

## 3

- mut vs shadowing
  - mut：型の変更ができない
  - shadowing：型の変更もできる
- signed/unsigned
  - i32 / f64 がとりあえずのベターな選択
- 配列とベクタ
  - 配列：固定長のケース（const系のみ）
  - ベクタ：それ以外の可変のすべてのケース。
- 式と文
  - 関数末尾にセミコロンがないとreturnされる。
  - 式は終端にセミコロンが、ない。
  - 文は終端にセミコロンが、ある。
  - 文は値を返さない。式は値を返す

## 4

### 所有権

動機：メモリ管理をしたい。
なんで？ヒープとスタックがある。
スタックは固定長、ヒープは可変長
プログラムでのリテラル、つまりハードコードされている文字列などはすべてスタックとして処理できる。
Rust的には、リテラル（＝プログラムに書かれている実際のstring/numなど）は、ビルドされた結果にバイナリにハードコードされる。そのため、スタックメモリで、固定長だけど速度が早い。
しかし、ユーザー入力などのInputな値などの変数はどれくらいの大きさの数が入るかわからない。つまり、どれくらいメモリ領域を確保すればよいかが事前にはわからない。そのため、ヒープメモリ、つまり可変長になる。

可変長なヒープメモリはポインタを使って複数のメモリ空間を横断してデータを保持する。そして、メモリ空間は任意のタイミングで掃除しないといけない。今までの言語では、GCにて定期的にクリーンにしていた。Rustでは所有権によってスコープ単位で不要になった変数、つまり使用しているメモリ領域をdropする。

Copyトレイトに適合している i32/bool/charなどはスタックメモリなので、別の変数に束縛してもムーブしない。

### スタックとヒープで挙動が違う

```rust
fn main() {
    let x = 2;
    let y = x;
    println!("{}, {}", x, y); // => 2, 2 
}
```

```rust
fn main() {
    let x = String::from("ok");
    let y = x;
    println!("{}, {}", x, y); // => Error 
}
```
すでにxのポインタ・長さ・許容量のメタデータをｙに「ムーブ」しているので。

### 参照渡し

```rust
let x = 2;
func1(x)
// or
func2(&x)

fn func1(x: i32) {
  // ...
}
fn func2(x: &i32) {
  // ...
}
```

- 借用＝関数の引数に参照を取ること。
- 借用ではイミュータブル。変更したいなら、`&mut i32` の宣言子がになる
- 借用では、所有権を持っているわけではない。

### スライス

- スライス＝可変配列
- 文字列スライス（&str）＝Stringへの参照（部分参照もできる
- 文字列リテラルは&str で、不変な場所の参照。

## 5

### 構造体

- 構造体_初期化_省略_記法
  - `User { name: name  } = User { name }`
- 構造体_更新_記法
  - `User { ..user1 }`
- タプル構造体
  - `Point(0, 1, 2)` / `Color(255, 255, 0)`

### impl

- implで構造体に関数を生やす。（ダックプログラミング）
- 規則：implの中のfnの第一引数は`&self`になる。これで構造体自体にアクセスできる。`self` / `&mut self`でもOK。


## 6
## 7
## 8
## 9
## 10
## 11
## 12
## 13
## 14
## 15
## 16
## 17
## 18
## 19

## 
次：https://doc.rust-jp.rs/book/second-edition/ch03-04-comments.html